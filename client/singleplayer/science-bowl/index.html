<!doctype html>
<html lang="en">

<head>
    <title>QB Reader - Science Bowl</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A text-based science bowl packet reader to read questions to yourself.">

    <link href="/apple-touch-icon.png" rel="apple-touch-icon">
    <link href="/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed">
    <link type="image/x-icon" href="/favicon.ico" rel="icon">

    <link href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css" rel="stylesheet">
    <script type="module" src="https://code.jquery.com/jquery-3.6.4.min.js"
        integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
    <script type="module" src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"
        integrity="sha256-lSjKY0/srUM9BE3dPm+c4fBo1dky2v27Gdjm2uoZaL0=" crossorigin="anonymous"></script>
    <link href="/bootstrap/light.css" rel="stylesheet">
    <link id="custom-css" href="/bootstrap/dark.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <script type="module" src="/scripts/apply-theme.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <style type="text/css">
        .custom-popover {
            width: 250px;
        }
        
        /* AI Help Styling */
        #ai-help-section {
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            background-color: #f8f9fa;
        }
        
        #ai-help-section h6 {
            color: #495057;
            font-weight: 600;
        }
        
        #get-ai-help {
            transition: all 0.2s ease-in-out;
        }
        
        #get-ai-help:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #ai-explanation .card {
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        #ai-explanation .card-header {
            border-bottom: none;
        }
        
        #explanation-content {
            line-height: 1.6;
            color: #212529;
        }
        
        .dark #ai-help-section {
            background-color: #2d3748;
            border-color: #4a5568;
        }
        
        .dark #ai-help-section h6 {
            color: #e2e8f0;
        }
        
        .dark #explanation-content {
            color: #e2e8f0;
        }
        
        /* Subject Statistics Table - Bottom Right Corner */
        #subject-stats-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 15px;
        }
        
        .dark #subject-stats-container {
            background-color: #2d3748;
            border-color: #4a5568;
        }
        
        #subject-stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        #subject-stats-table-container {
            max-height: 400px;
            overflow-y: auto;
        }
        
        #subject-stats-container table {
            margin-bottom: 0;
        }
        #subject-stats-container.collapsed {
            top: auto;
            bottom: 20px;
            max-width: 240px;
            padding: 10px 12px;
        }
        #subject-stats-container.collapsed #subject-stats-body-wrap {
            display: none;
        }
        #subject-stats-container.collapsed #subject-stats-header h6 {
            margin-bottom: 0;
        }
        #topics-needed-section.collapsed .card-body {
            display: none;
        }
        .collapse-toggle-icon {
            transition: transform 0.2s ease;
        }
        #subject-stats-container.collapsed .collapse-toggle-icon,
        #topics-needed-section.collapsed .collapse-toggle-icon {
            transform: rotate(180deg);
        }

        /* Topics needing improvement UI */
        #topics-needed-section .card {
            border: 1px solid #dee2e6;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }

        #topics-needed-section .card-header {
            background-color: #f8f9fa;
        }

        #topics-needed-list .topic-item + .topic-item {
            border-top: 1px solid rgba(0,0,0,0.05);
            padding-top: 0.75rem;
            margin-top: 0.75rem;
        }

        #topics-needed-list .topic-summary-text {
            font-weight: 600;
        }

        .dark #topics-needed-section .card {
            background-color: #1f2937;
            border-color: #4a5568;
        }

        .dark #topics-needed-section .card-header {
            background-color: #2d3748;
        }

        .dark #topics-needed-list .topic-item + .topic-item {
            border-color: rgba(255,255,255,0.08);
        }
        #buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: flex-end;
        }
        
    </style>
</head>

<body>
    <nav class="navbar navbar-light navbar-expand-lg bg-custom" id="navbar" style="z-index: 10">
        <div class="container-fluid">
            <a class="navbar-brand ms-1 py-0" id="logo" href="/">
                <span class="logo-prefix">QB</span><span class="logo-suffix">Reader</span>
            </a>
            <button class="navbar-toggler" data-bs-target="#navbarSupportedContent" data-bs-toggle="collapse" type="button"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <div class="navbar-nav me-auto mb-2 mb-lg-0">
                    <a class="nav-link active" href="/singleplayer/" aria-current="page">Singleplayer</a>
                    <a class="nav-link" href="/multiplayer/">Multiplayer</a>
                    <a class="nav-link" href="/database/">Database</a>
                    <a class="nav-link" href="/frequency-list/">Frequency List</a>
                    <a class="nav-link" href="/geoword/">Geoword</a>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                            Tools
                        </a>
                        <ul class="dropdown-menu">
                            <a class="dropdown-item" href="/tools/api-docs/">API Docs</a>
                            <a class="dropdown-item" href="/tools/packet-parser/">Packet Parser</a>
                        </ul>
                    </li>
                    <a class="nav-link" href="/about/">About</a>
                    <a class="nav-link" href="/settings/">Settings</a>
                </div>
                <div class="d-flex">
                    <ul class="navbar-nav mb-2 mb-lg-0">
                        <a class="nav-link" href="/user/login" id="login-link">Log in</a>
                    </ul>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid mt-3 mb-5 pb-5 px-xxl-5">
        <div class="toast-container position-fixed top-0 end-0 p-3">
            <div id="star-toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="toast-header">
                    <strong class="me-auto">You must be logged in to star questions.</strong>
                    <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            </div>
        </div>
        <div class="toast-container position-fixed top-0 end-0 p-3">
            <div id="funny-toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="toast-header" style="background-color: yellow;">
                    <h1 id="funny-toast-text" class="me-auto text-danger"></h1>
                    <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            </div>
        </div>
        <div class="row" id="info">
            <div class="options d-lg-block col-12 col-lg-3 order-lg-1 mb-5" id="settings">
                <div class="timer d-block p-1 text-center" id="timer">
                    <span class="face">0</span><span class="fraction">.0</span>
                </div>
                <hr>
                <ul class="list-group d-none" id="player-list-group"></ul>
                <hr class="d-none" id="player-list-group-hr">
                <label class="form-check-label mb-1" for="set-mode">Choose a mode:</label>
                <select class="form-select mb-2" id="set-mode">
                    <option value="select by set name">Select by Set Name</option>
                    <option value="random questions" selected>Random Questions</option>
                    <option value="starred questions">Starred Questions</option>
                    <option value="local packet">Upload Local Packet</option>
                </select>
                <div class="d-none" id="local-packet-settings">
                    You may need to <a href="/tools/packet-parser/">parse the packet here</a> into .json.
                    To play a <a href="/database/">database search</a>, download the results as a .json file and upload it here!
                    <input class="form-control" type="file" id="local-packet-input" accept=".json">
                </div>
                <div class="d-none" id="set-settings">
                    <input class="form-control" id="set-name" type="text" placeholder="Set Name" list="set-list">
                    <datalist id="set-list"></datalist>
                    <input class="form-control my-1" id="packet-number" type="text" placeholder="Packet Numbers">
                </div>
                <div class="mt-2" id="general-settings">
                    <div class="text-center mb-2 d-flex flex-wrap justify-content-center gap-2">
                        <button class="btn btn-success" id="category-select-button" data-bs-target="#category-modal-root"
                            data-bs-toggle="modal" type="button">Categories</button>
                        <button class="btn btn-outline-primary" id="competition-select-button" data-bs-target="#competition-modal"
                            data-bs-toggle="modal" type="button">Competitions</button>
                    </div>
                    <!-- AI mode toggle removed -->
                    <hr>
                    <!-- Removed: Type to answer, Allow rebuzzes, Show question history, Enable timer -->
                    <div class="form-check form-switch mb-2">
                        <input class="form-check-input" id="toggle-speech" type="checkbox" role="switch">
                        <label class="form-check-label" for="toggle-speech">Enable text-to-speech</label>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" id="toggle-ms-mode" type="checkbox" role="switch">
                        <label class="form-check-label" for="toggle-ms-mode">Middle school questions</label>
                        <div class="form-text">
                            Off = high school sets (filters out MSNSB). On = only MSNSB middle school questions.
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label" for="reading-speed">
                            Reading speed: <span id="reading-speed-display">50</span>
                        </label>
                        <input class="form-range" id="reading-speed" type="range" min="0" max="100" step="5" value="50">
                    <div class="form-text">Slide left for slower reading, right for faster.</div>
                    </div>
                    <div class="mb-2"></div>
                </div>
            </div>
            <div class="col-12 col-lg-9" id="content">
                <form id="answer-form">
                    <!-- User enters answer here -->
                    <div class="d-flex justify-content-between mb-3">
                        <span id="statline">SCORE: 0</span>
                        <span class="ps-5 me-lg-2" id="question-metadata">
                            <b id="question-info">
                                <span id="set-name-info"></span>
                                Packet <span id="packet-number-info">-</span>
                                Question <span id="question-number-info">-</span>
                                of <span id="packet-length-info">-</span>
                            </b>
                        </span>
                        <div class="d-flex gap-2">
                            <!-- Debug button for testing AI help -->
                            <button type="button" class="btn btn-warning btn-sm" id="test-ai-help">
                                Test AI Help
                            </button>
                        </div>
                    </div>
                    <div id="question" class="mb-3"></div>
                    <div id="answer-display" class="mb-3"></div>
                    <div id="user-answer" class="mb-3"></div>
                        <div id="ai-help-section" class="mb-3 d-none">
                            <div class="d-flex justify-content-between align-items-center mb-2 gap-2 flex-wrap">
                                <h6 class="mb-0">Need help understanding this question?</h6>
                                <div class="ms-auto d-flex gap-2">
                                    <button type="button" class="btn btn-outline-info btn-sm" id="get-ai-help">
                                        <i class="bi bi-lightbulb"></i> Get AI Explanation
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary btn-sm" id="get-suggested-reading">
                                        <i class="bi bi-book"></i> Suggested Reading
                                    </button>
                                    <button type="button" class="btn btn-outline-success btn-sm" id="get-extra-practice">
                                        <i class="bi bi-list-check"></i> Extra Practice
                                    </button>
                                    <button type="button" class="btn btn-outline-primary btn-sm d-none" id="plead-equivalence">
                                        <i class="bi bi-hand-thumbs-up"></i> I was correct
                                    </button>
                                </div>
                            </div>
                            <div id="plead-inline" class="d-none">
                              <div id="plead-inline-alert" class="alert alert-secondary py-1 px-2 mb-2" style="font-size: 0.9rem;"></div>
                            </div>
                            <div id="ai-explanation" class="d-none">
                                <div class="card">
                                    <div class="card-header bg-info text-white">
                                    <h6 class="mb-0">AI Explanation</h6>
                                </div>
                                <div class="card-body">
                                    <div id="explanation-content"></div>
                                    <div id="explanation-loading" class="text-center d-none">
                                        <div class="spinner-border spinner-border-sm" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <span class="ms-2">Getting AI explanation...</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card mt-3 d-none" id="suggested-reading">
                                <div class="card-header bg-secondary text-white">
                                    <h6 class="mb-0">Suggested Reading</h6>
                                </div>
                                <div class="card-body">
                                    <div id="suggested-reading-content"></div>
                                    <div id="suggested-reading-loading" class="text-center d-none">
                                        <div class="spinner-border spinner-border-sm" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <span class="ms-2">Finding reputable resources...</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card mt-3 d-none" id="extra-practice">
                                <div class="card-header bg-success text-white">
                                    <h6 class="mb-0">Extra Practice</h6>
                                </div>
                                <div class="card-body">
                                    <div id="extra-practice-content"></div>
                                    <div id="extra-practice-loading" class="text-center d-none">
                                        <div class="spinner-border spinner-border-sm" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <span class="ms-2">Generating practice questions...</span>
                                    </div>
                                </div>
                            </div>
                            <div class="card mt-3 d-none" id="plead-result">
                                <div class="card-header bg-primary text-white">
                                    <h6 class="mb-0">AI Equivalence Review</h6>
                                </div>
                                <div class="card-body">
                                    <div id="plead-result-content"></div>
                                    <div id="plead-result-loading" class="text-center d-none">
                                        <div class="spinner-border spinner-border-sm" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <span class="ms-2">Asking AI to review your answer...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="answer-input-group" class="input-group mb-3 d-none">
                        <input class="form-control" id="answer-input" type="text" placeholder="Enter answer" autocomplete="off">
                        <button class="btn btn-success" id="answer-submit" type="submit">Submit</button>
                    </div>
                    <div id="topics-needed-section" class="mb-3">
                        <div class="card">
                            <div class="card-header d-flex align-items-center gap-2 flex-wrap">
                                <div>
                                    <h6 class="mb-0">Topics Needing Improvement</h6>
                                    <small class="text-muted" id="topics-needed-count">Log of AI summaries for missed tossups.</small>
                                </div>
                                <div class="ms-auto d-flex gap-2 align-items-center flex-wrap">
                                    <button type="button" class="btn btn-outline-secondary btn-sm" id="topics-collapse-toggle" aria-expanded="true" title="Collapse topics list">
                                        <i class="bi bi-chevron-up collapse-toggle-icon"></i>
                                    </button>
                                    <button type="button" class="btn btn-outline-secondary btn-sm" id="topics-needed-refresh">
                                        <i class="bi bi-arrow-repeat"></i> Refresh summaries
                                    </button>
                                    <button type="button" class="btn btn-outline-danger btn-sm" id="topics-needed-clear">
                                        <i class="bi bi-trash"></i> Clear
                                    </button>
                                </div>
                            </div>
                            <div class="card-body">
                                <p class="text-muted mb-0" id="topics-needed-empty">No missed tossups logged yet. We will add short AI-generated topic summaries whenever you miss a question.</p>
                                <ul class="list-unstyled mb-0 d-none" id="topics-needed-list"></ul>
                            </div>
                        </div>
                    </div>
                </form>
                <ul class="room-history list-unstyled" id="room-history"></ul>
            </div>
        </div>
    </div>

    <div class="container-fluid py-3 px-xxl-5 position-fixed bottom-0 bg-body">
        <div class="row">
            <div class="col-12 col-lg-9" id="buttons">
                <button class="btn btn-primary" id="start" data-bs-toggle="tooltip" data-bs-placement="top"
                    title="Shortcut: N">Start/Next</button>
                <button class="btn btn-primary" id="pause" data-bs-placement="top" data-bs-toggle="tooltip" type="button"
                    title="Shortcut: P">Pause</button>
                <button class="btn btn-primary" id="buzz" data-bs-placement="top" data-bs-toggle="tooltip" type="button"
                    title="Shortcut: Space" disabled>Buzz</button>
            </div>
        </div>
    </div>

    <div class="modal fade" id="category-modal-root" tabindex="-1" aria-labelledby="category-modal-label" onclick="console.log('Modal clicked')">
      <div class="modal-dialog modal-dialog-scrollable">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title me-2" id="category-modal-label">Select Categories</h5>
            <button class="btn btn-primary me-1" id="toggle-all" onclick="console.log('Toggle all clicked. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.import(window.room.categoryManager.categories.length === 0 ? {categories: ['MATH', 'PHYSICS', 'CHEMISTRY', 'BIOLOGY', 'EARTH AND SPACE', 'ENERGY']} : {}); window.room.categoryManager.loadCategoryModal(); window.room.query.subjects = window.room.categoryManager.categories; window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">Toggle all</button>
            <button class="btn btn-primary" id="toggle-percent-view" onclick="console.log('Percent view clicked. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.percentView = !window.room.categoryManager.percentView; window.room.categoryManager.loadCategoryModal(); window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">% view</button>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="row" id="non-percent-view">
              <div class="col-12" id="categories">
                <h5 class="text-center">Category</h5>
                <div>
                  <input type="checkbox" class="btn-check category-checkbox" autocomplete="off" id="MATH" onclick="console.log('Category checkbox clicked: MATH. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.updateCategory('MATH'); window.room.categoryManager.loadCategoryModal(); window.room.query.subjects = window.room.categoryManager.categories; window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">
                  <label class="btn btn-outline-primary w-100 rounded-0 my-1" for="MATH">MATH<br></label>
                </div>
                <div>
                  <input type="checkbox" class="btn-check category-checkbox" autocomplete="off" id="PHYSICS" onclick="console.log('Category checkbox clicked: PHYSICS. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.updateCategory('PHYSICS'); window.room.categoryManager.loadCategoryModal(); window.room.query.subjects = window.room.categoryManager.categories; window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">
                  <label class="btn btn-outline-danger w-100 rounded-0 my-1" for="PHYSICS">PHYSICS<br></label>
                </div>
                <div>
                  <input type="checkbox" class="btn-check category-checkbox" autocomplete="off" id="CHEMISTRY" onclick="console.log('Category checkbox clicked: CHEMISTRY. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.updateCategory('CHEMISTRY'); window.room.categoryManager.loadCategoryModal(); window.room.query.subjects = window.room.categoryManager.categories; window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">
                  <label class="btn btn-outline-warning w-100 rounded-0 my-1" for="CHEMISTRY">CHEMISTRY<br></label>
                </div>
                <div>
                  <input type="checkbox" class="btn-check category-checkbox" autocomplete="off" id="BIOLOGY" onclick="console.log('Category checkbox clicked: BIOLOGY. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.updateCategory('BIOLOGY'); window.room.categoryManager.loadCategoryModal(); window.room.query.subjects = window.room.categoryManager.categories; window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">
                  <label class="btn btn-outline-success w-100 rounded-0 my-1" for="BIOLOGY">BIOLOGY<br></label>
                </div>
                <div>
                  <input type="checkbox" class="btn-check category-checkbox" autocomplete="off" id="EARTH AND SPACE" onclick="console.log('Category checkbox clicked: EARTH AND SPACE. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.updateCategory('EARTH AND SPACE'); window.room.categoryManager.loadCategoryModal(); window.room.query.subjects = window.room.categoryManager.categories; window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">
                  <label class="btn btn-outline-info w-100 rounded-0 my-1" for="EARTH AND SPACE">EARTH AND SPACE<br></label>
                </div>
                <div>
                  <input type="checkbox" class="btn-check category-checkbox" autocomplete="off" id="ENERGY" onclick="console.log('Category checkbox clicked: ENERGY. Current categories:', window.room.categoryManager.categories); window.room.categoryManager.updateCategory('ENERGY'); window.room.categoryManager.loadCategoryModal(); window.room.query.subjects = window.room.categoryManager.categories; window.localStorage.setItem('singleplayer-science-bowl-categories', JSON.stringify({...window.room.categoryManager.export(), version: '2025-05-07'})); document.querySelectorAll('.category-checkbox').forEach(checkbox => checkbox.checked = window.room.categoryManager.categories.includes(checkbox.id));">
                  <label class="btn btn-outline-secondary w-100 rounded-0 my-1" for="ENERGY">ENERGY<br></label>
                </div>
              </div>
            </div>
            <div class="row d-none" id="percent-view">
              <div class="col-12">
                <table class="table">
                  <tbody>
                    <tr>
                      <th style="width: 50%">MATH</th>
                      <td style="width: 50%">
                        <span class="font-monospace me-1 category-percent">0%</span>
                        <div class="btn-group btn-group-sm me-1" role="group">
                          <button type="button" class="btn btn-outline-secondary">-</button>
                          <button type="button" class="btn btn-outline-secondary">+</button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                          <button type="button" class="btn btn-outline-secondary">Min</button>
                          <button type="button" class="btn btn-outline-secondary">50%</button>
                          <button type="button" class="btn btn-outline-secondary">Max</button>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <th>PHYSICS</th>
                      <td>
                        <span class="font-monospace me-1 category-percent">0%</span>
                        <div class="btn-group btn-group-sm me-1" role="group">
                          <button type="button" class="btn btn-outline-secondary">-</button>
                          <button type="button" class="btn btn-outline-secondary">+</button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                          <button type="button" class="btn btn-outline-secondary">Min</button>
                          <button type="button" class="btn btn-outline-secondary">50%</button>
                          <button type="button" class="btn btn-outline-secondary">Max</button>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <th>CHEMISTRY</th>
                      <td>
                        <span class="font-monospace me-1 category-percent">0%</span>
                        <div class="btn-group btn-group-sm me-1" role="group">
                          <button type="button" class="btn btn-outline-secondary">-</button>
                          <button type="button" class="btn btn-outline-secondary">+</button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                          <button type="button" class="btn btn-outline-secondary">Min</button>
                          <button type="button" class="btn btn-outline-secondary">50%</button>
                          <button type="button" class="btn btn-outline-secondary">Max</button>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <th>BIOLOGY</th>
                      <td>
                        <span class="font-monospace me-1 category-percent">0%</span>
                        <div class="btn-group btn-group-sm me-1" role="group">
                          <button type="button" class="btn btn-outline-secondary">-</button>
                          <button type="button" class="btn btn-outline-secondary">+</button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                          <button type="button" class="btn btn-outline-secondary">Min</button>
                          <button type="button" class="btn btn-outline-secondary">50%</button>
                          <button type="button" class="btn btn-outline-secondary">Max</button>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <th>EARTH AND SPACE</th>
                      <td>
                        <span class="font-monospace me-1 category-percent">0%</span>
                        <div class="btn-group btn-group-sm me-1" role="group">
                          <button type="button" class="btn btn-outline-secondary">-</button>
                          <button type="button" class="btn btn-outline-secondary">+</button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                          <button type="button" class="btn btn-outline-secondary">Min</button>
                          <button type="button" class="btn btn-outline-secondary">50%</button>
                          <button type="button" class="btn btn-outline-secondary">Max</button>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <th>ENERGY</th>
                      <td>
                        <span class="font-monospace me-1 category-percent">0%</span>
                        <div class="btn-group btn-group-sm me-1" role="group">
                          <button type="button" class="btn btn-outline-secondary">-</button>
                          <button type="button" class="btn btn-outline-secondary">+</button>
                        </div>
                        <div class="btn-group btn-group-sm" role="group">
                          <button type="button" class="btn btn-outline-secondary">Min</button>
                          <button type="button" class="btn btn-outline-secondary">50%</button>
                          <button type="button" class="btn btn-outline-secondary">Max</button>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <th>Total Percent:</th>
                      <td class="font-monospace">
                        <span class="me-1">0%</span>
                        <button type="button" class="btn btn-sm btn-outline-secondary">Reset</button>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="modal fade" id="competition-modal" tabindex="-1" aria-labelledby="competition-modal-label">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="competition-modal-label">Select Competitions</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="text-muted small mb-3">
                        Choose which competitions to include when pulling questions.
                        Leave everything unchecked to allow questions from every competition.
                    </p>
                    <div class="form-check mb-2">
                        <input class="form-check-input competition-checkbox" type="checkbox" value="SMH" id="competition-smh">
                        <label class="form-check-label" for="competition-smh">SMH</label>
                    </div>
                    <div class="form-check mb-2">
                        <input class="form-check-input competition-checkbox" type="checkbox" value="NSB" id="competition-nsb">
                        <label class="form-check-label" for="competition-nsb">NSB</label>
                    </div>
                    <div class="form-check mb-2">
                        <input class="form-check-input competition-checkbox" type="checkbox" value="BASH" id="competition-bash">
                        <label class="form-check-label" for="competition-bash">BASH</label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-secondary" id="clear-competition-selection">Clear</button>
                    <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Done</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="ai-settings-modal">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">AI Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Choose an AI:</p>
                    <form id="choose-ai"></form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="report-question-modal" tabindex="-3">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Report Question</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Please describe the issue with this question:</p>
                    <textarea class="form-control" id="report-question-text" rows="3"></textarea>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="report-question-submit">Submit</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function () {
            if (window.__sbInlineSpeedControl) { return; }
            window.__sbInlineSpeedControl = true;
            const LOG_PREFIX = '[ScienceBowl InlineSpeed]';
            const USER_ID = 'user';
            let sliderEl = null;
            let displayEl = null;
            let pendingValue = null;

            const clampSpeed = (value) => {
                const num = Number.isFinite(value) ? value : 50;
                return Math.min(100, Math.max(0, Math.round(num)));
            };

            const log = (...args) => { console.log(LOG_PREFIX, ...args); };

            function updateUI (value, { logUpdate = false } = {}) {
                if (!sliderEl || !displayEl) { return; }
                const clamped = clampSpeed(value);
                const stringValue = String(clamped);
                if (sliderEl.value !== stringValue) {
                    sliderEl.value = stringValue;
                }
                displayEl.textContent = stringValue;
                if (logUpdate) {
                    log('Display updated', { clamped });
                }
            }

            function sendToRoom (value) {
                const clamped = clampSpeed(value);
                const room = window.room;
                if (!room) {
                    pendingValue = clamped;
                    log('Room not ready, queued value', clamped);
                    return;
                }
                room.settings = room.settings || {};
                room.settings.readingSpeed = clamped;
                try {
                    log('Sending reading speed', clamped);
                    room.message?.(USER_ID, { type: 'set-reading-speed', readingSpeed: clamped });
                } catch (err) {
                    console.error(LOG_PREFIX, 'Failed to send reading speed', err);
                }
            }

            function handleSliderInput (event) {
                const value = clampSpeed(Number(event.target.value));
                updateUI(value, { logUpdate: true });
                sendToRoom(value);
            }

            function attachSlider () {
                sliderEl = document.getElementById('reading-speed');
                displayEl = document.getElementById('reading-speed-display');
                if (!sliderEl || !displayEl) {
                    console.warn(LOG_PREFIX, 'Reading speed slider or label missing');
                    return;
                }
                const initial = clampSpeed(Number(sliderEl.value));
                updateUI(initial);
                sliderEl.addEventListener('input', handleSliderInput);
            }

            function hookRoom (room) {
                if (!room || room.__inlineSpeedHooked) { return; }
                room.__inlineSpeedHooked = true;
                const originalSetReadingSpeed = typeof room.setReadingSpeed === 'function'
                    ? room.setReadingSpeed.bind(room)
                    : null;

                if (originalSetReadingSpeed) {
                    room.setReadingSpeed = function patchedSetReadingSpeed (userId, payload = {}) {
                        const normalized = clampSpeed(Number(payload.readingSpeed));
                        updateUI(normalized, { logUpdate: true });
                        room.settings = room.settings || {};
                        room.settings.readingSpeed = normalized;
                        return originalSetReadingSpeed(userId, { ...payload, readingSpeed: normalized });
                    };
                    log('Attached room.setReadingSpeed hook');
                }

                if (typeof room.settings?.readingSpeed === 'number') {
                    updateUI(room.settings.readingSpeed);
                }

                if (typeof pendingValue === 'number') {
                    sendToRoom(pendingValue);
                    pendingValue = null;
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                attachSlider();
                hookRoom(window.room);
                const roomPoll = setInterval(() => {
                    if (window.room) {
                        hookRoom(window.room);
                        clearInterval(roomPoll);
                    }
                }, 250);
            });
        })();
    </script>

    <script type="module" src="/bootstrap/bootstrap.bundle.min.js"></script>
    <script type="module" src="/script.js"></script>
    <script type="module" src="index.min.js"></script>
    <script>
        (function setupCompetitionFilters () {
            const QUERY_STORAGE_KEY = 'singleplayer-science-bowl-query';
            const QUERY_VERSION = '2025-05-07';
            const COMPETITIONS = ['SMH', 'NSB', 'BASH'];
            const MIDDLE_SCHOOL_COMPETITION = 'MSNSB';
            const MODE_STORAGE_KEY = 'singleplayer-science-bowl-level';
            const CHECKBOX_SELECTOR = '.competition-checkbox';
            const MS_SWITCH_ID = 'toggle-ms-mode';
            const COMPETITION_BUTTON_ID = 'competition-select-button';
            let cachedSelection = [];
            let msMode = false;
            let roomSyncInterval = null;

            function safeParse (value) {
                if (typeof value !== 'string' || value.length === 0) {
                    return null;
                }
                try {
                    return JSON.parse(value);
                } catch (error) {
                    console.warn('[Science Bowl] Failed to parse saved query state', error);
                    return null;
                }
            }

            function normalizeSelection (selection = []) {
                return selection.filter((name) => COMPETITIONS.includes(name));
            }

            function loadInitialSelection () {
                const saved = safeParse(window.localStorage.getItem(QUERY_STORAGE_KEY));
                if (!Array.isArray(saved?.competitions)) { return []; }
                return normalizeSelection(saved.competitions);
            }

            function loadSavedMsMode () {
                const saved = safeParse(window.localStorage.getItem(MODE_STORAGE_KEY));
                return saved?.mode === 'MS';
            }

            function persistSelection (selection) {
                try {
                    const baseQuery = { ...(window.room?.query || {}) };
                    baseQuery.competitions = selection.slice();
                    window.localStorage.setItem(QUERY_STORAGE_KEY, JSON.stringify({ ...baseQuery, version: QUERY_VERSION }));
                } catch (error) {
                    console.warn('[Science Bowl] Failed to persist competition filters', error);
                }
            }

            function persistMsMode () {
                try {
                    window.localStorage.setItem(MODE_STORAGE_KEY, JSON.stringify({ mode: msMode ? 'MS' : 'HS' }));
                } catch (error) {
                    console.warn('[Science Bowl] Failed to persist MS/HS mode', error);
                }
            }

            function assignSelectionToRoom (selection) {
                if (!window.room || !window.room.query) {
                    if (roomSyncInterval === null) {
                        roomSyncInterval = setInterval(() => {
                            if (window.room && window.room.query) {
                                assignSelectionToRoom(selection);
                                clearInterval(roomSyncInterval);
                                roomSyncInterval = null;
                            }
                        }, 100);
                    }
                    return;
                }
                window.room.query.competitions = selection.slice();
            }

            function syncCheckboxes (selection = cachedSelection) {
                document.querySelectorAll(CHECKBOX_SELECTOR).forEach((input) => {
                    input.checked = selection.includes(input.value);
                });
            }

            function getSelectionFromUI () {
                const values = Array.from(document.querySelectorAll(CHECKBOX_SELECTOR))
                    .filter((input) => input.checked)
                    .map((input) => input.value);
                return normalizeSelection(values);
            }

            function getEffectiveSelection () {
                if (msMode) {
                    return [MIDDLE_SCHOOL_COMPETITION];
                }
                const sanitized = normalizeSelection(cachedSelection);
                if (sanitized.length === 0) {
                    return COMPETITIONS.slice();
                }
                return sanitized;
            }

            function updateRoomCompetitions () {
                const effective = getEffectiveSelection();
                assignSelectionToRoom(effective);
                persistSelection(effective);
            }

            function handleSelectionChange () {
                cachedSelection = getSelectionFromUI();
                updateRoomCompetitions();
            }

            function syncCompetitionControlsDisabled () {
                const disabled = msMode;
                const button = document.getElementById(COMPETITION_BUTTON_ID);
                if (button) {
                    button.disabled = disabled;
                }
                const clearButton = document.getElementById('clear-competition-selection');
                if (clearButton) {
                    clearButton.disabled = disabled;
                }
                document.querySelectorAll(CHECKBOX_SELECTOR).forEach((input) => {
                    input.disabled = disabled;
                });
            }

            cachedSelection = loadInitialSelection();
            msMode = loadSavedMsMode();
            updateRoomCompetitions();

            document.addEventListener('DOMContentLoaded', () => {
                syncCheckboxes();
                syncCompetitionControlsDisabled();

                const msSwitch = document.getElementById(MS_SWITCH_ID);
                if (msSwitch) {
                    msSwitch.checked = msMode;
                    msSwitch.addEventListener('change', () => {
                        msMode = msSwitch.checked;
                        persistMsMode();
                        syncCompetitionControlsDisabled();
                        updateRoomCompetitions();
                    });
                }

                document.querySelectorAll(CHECKBOX_SELECTOR).forEach((input) => {
                    input.addEventListener('change', handleSelectionChange);
                });

                document.getElementById('clear-competition-selection')?.addEventListener('click', () => {
                    document.querySelectorAll(CHECKBOX_SELECTOR).forEach((input) => {
                        input.checked = false;
                    });
                    handleSelectionChange();
                });

                document.getElementById('competition-modal')?.addEventListener('show.bs.modal', () => {
                    syncCheckboxes(msMode ? [] : normalizeSelection(window.room?.query?.competitions || cachedSelection));
                });
            });
        })();
    </script>
    <script>
        // Initialize updateStatDisplay if not already defined
        if (typeof window.updateStatDisplay !== 'function') {
            window.updateStatDisplay = function(player) {
                const statline = document.getElementById('statline');
                if (!statline) { return; }
                const score = (player && typeof player.score === 'number' && !Number.isNaN(player.score))
                    ? player.score
                    : (parseInt(statline.textContent.split(': ')[1]) || 0);
                statline.textContent = `SCORE: ${score}`;
            };
        }

        // Global function for pause button
        function handlePause() {
            console.log('Pause button clicked');
            if (!window.room) {
                console.error('Room not initialized');
                return;
            }
            
            const buzzButton = document.getElementById('buzz');
            const pauseButton = document.getElementById('pause');
            
            // Toggle pause state
            const isPaused = pauseButton.textContent === 'Resume';
            
            if (isPaused) {
                // Resuming - enable buzz button if we're in reading state
                if (window.room.tossupProgress === 'READING') {
                    buzzButton.disabled = false;
                }
                pauseButton.textContent = 'Pause';
            } else {
                // Pausing - disable buzz button
                buzzButton.disabled = true;
                pauseButton.textContent = 'Resume';
            }
            
            window.room.message('user', { type: 'pause' });
        }
    </script>
    <script>
        (function initializeSubjectAdjustmentHelpers () {
            window.sbSubjectStatAdjustments = window.sbSubjectStatAdjustments || {};
            window.sbTrackSubjectStatAdjustment = function trackSubjectAdjustment (subject, deltas = {}) {
                if (!subject) { return; }
                const normalized = (typeof subject === 'string' ? subject.toUpperCase() : subject) || '';
                if (!normalized) { return; }
                const current = window.sbSubjectStatAdjustments[normalized] || { correct: 0, wrong: 0, sped: 0, negs: 0 };
                if (typeof deltas.correct === 'number') { current.correct += deltas.correct; }
                if (typeof deltas.wrong === 'number') { current.wrong += deltas.wrong; }
                if (typeof deltas.sped === 'number') { current.sped += deltas.sped; }
                if (typeof deltas.negs === 'number') { current.negs += deltas.negs; }
                window.sbSubjectStatAdjustments[normalized] = current;
            };
        })();
    </script>

    <!-- Inline AI Help logic to ensure it runs regardless of module timing -->
    <script>
      (function () {
        if (window.__sbAiInlineLoaded) return; // guard to avoid double init
        window.__sbAiInlineLoaded = true;

        function sbShowAIHelpSection() {
          const el = document.getElementById('ai-help-section');
          if (!el) { console.error('[SBAI] ai-help-section not found'); return; }
          el.classList.remove('d-none');
          sbHideAIExplanation();
          try { el.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch (_) {}
        }

        function sbHideAIHelpSection() {
          const el = document.getElementById('ai-help-section');
          if (!el) return;
          el.classList.add('d-none');
          sbHideAIExplanation();
          sbHideSuggested();
        }

        function sbHideAIExplanation() {
          const wrap = document.getElementById('ai-explanation');
          const content = document.getElementById('explanation-content');
          const loading = document.getElementById('explanation-loading');
          if (wrap) wrap.classList.add('d-none');
          if (content) content.innerHTML = '';
          if (loading) loading.classList.add('d-none');
          // Also clear extra sections
          sbHideSuggested();
          sbHidePractice();
          // Also clear plead UI
          (function(){
            const card = document.getElementById('plead-result');
            const content2 = document.getElementById('plead-result-content');
            const loading2 = document.getElementById('plead-result-loading');
            if (content2) content2.innerHTML = '';
            if (loading2) loading2.classList.add('d-none');
            if (card) card.classList.add('d-none');
            const btn = document.getElementById('plead-equivalence');
            if (btn) btn.classList.add('d-none');
            const inline = document.getElementById('plead-inline');
            const inlineAlert = document.getElementById('plead-inline-alert');
            if (inline) inline.classList.add('d-none');
            if (inlineAlert) inlineAlert.textContent = '';
          })();
        }

        function sbShowAIExplanation() {
          const wrap = document.getElementById('ai-explanation');
          if (wrap) wrap.classList.remove('d-none');
        }

        function sbShowLoading() {
          const loading = document.getElementById('explanation-loading');
          const content = document.getElementById('explanation-content');
          if (content) content.innerHTML = '';
          if (loading) loading.classList.remove('d-none');
        }

        function sbHideLoading() {
          const loading = document.getElementById('explanation-loading');
          if (loading) loading.classList.add('d-none');
        }

        function sbDisplayExplanation(text) {
          const content = document.getElementById('explanation-content');
          if (content) content.innerHTML = (text || '').replace(/\n/g, '<br>');
        }

        function sbShowSuggested() {
          const card = document.getElementById('suggested-reading');
          const content = document.getElementById('suggested-reading-content');
          if (content) content.innerHTML = '';
          if (card) card.classList.remove('d-none');
          try { card.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch (_) {}
        }

        function sbHideSuggested() {
          const card = document.getElementById('suggested-reading');
          const content = document.getElementById('suggested-reading-content');
          const loading = document.getElementById('suggested-reading-loading');
          if (content) content.innerHTML = '';
          if (loading) loading.classList.add('d-none');
          if (card) card.classList.add('d-none');
        }

        function sbShowSuggestedLoading() {
          const loading = document.getElementById('suggested-reading-loading');
          const content = document.getElementById('suggested-reading-content');
          if (content) content.innerHTML = '';
          if (loading) loading.classList.remove('d-none');
        }

        function sbHideSuggestedLoading() {
          const loading = document.getElementById('suggested-reading-loading');
          if (loading) loading.classList.add('d-none');
        }

        function sbShowPractice() {
          const card = document.getElementById('extra-practice');
          const content = document.getElementById('extra-practice-content');
          if (content) content.innerHTML = '';
          if (card) card.classList.remove('d-none');
          try { card.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch (_) {}
        }

        function sbHidePractice() {
          const card = document.getElementById('extra-practice');
          const content = document.getElementById('extra-practice-content');
          const loading = document.getElementById('extra-practice-loading');
          if (content) content.innerHTML = '';
          if (loading) loading.classList.add('d-none');
          if (card) card.classList.add('d-none');
        }

        function sbShowPracticeLoading() {
          const loading = document.getElementById('extra-practice-loading');
          const content = document.getElementById('extra-practice-content');
          if (content) content.innerHTML = '';
          if (loading) loading.classList.remove('d-none');
        }

        function sbHidePracticeLoading() {
          const loading = document.getElementById('extra-practice-loading');
          if (loading) loading.classList.add('d-none');
        }

        // Plead (equivalence) UI helpers
        function sbShowPlead() {
          const card = document.getElementById('plead-result');
          const content = document.getElementById('plead-result-content');
          if (content) content.innerHTML = '';
          if (card) {
            card.classList.remove('d-none');
            console.log('[SBAI] showing verdict card: removed d-none');
          } else {
            console.warn('[SBAI] verdict card not found (#plead-result)');
          }
          try { card.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch (_) {}
        }

        function sbHidePlead() {
          const card = document.getElementById('plead-result');
          const content = document.getElementById('plead-result-content');
          const loading = document.getElementById('plead-result-loading');
          if (content) content.innerHTML = '';
          if (loading) loading.classList.add('d-none');
          if (card) card.classList.add('d-none');
          const btn = document.getElementById('plead-equivalence');
          if (btn) btn.classList.add('d-none');
        }

        function sbShowPleadLoading() {
          const loading = document.getElementById('plead-result-loading');
          const content = document.getElementById('plead-result-content');
          if (content) content.innerHTML = '';
          if (loading) {
            loading.classList.remove('d-none');
            console.log('[SBAI] verdict loading spinner shown');
          }
        }

        function sbHidePleadLoading() {
          const loading = document.getElementById('plead-result-loading');
          if (loading) {
            loading.classList.add('d-none');
            console.log('[SBAI] verdict loading spinner hidden');
          }
        }

        function sbRenderPleadResult(equivalent, verdictText) {
          const content = document.getElementById('plead-result-content');
          if (!content) return;
          const shortText = (verdictText || '').trim();
          if (equivalent) {
            content.innerHTML = '<div class="alert alert-success mb-0"><strong>Accepted:</strong> ' + (shortText || 'Equivalent answer.') + '</div>';
            console.log('[SBAI] rendered verdict: Accepted', { text: shortText });
          } else {
            content.innerHTML = '<div class="alert alert-warning mb-0"><strong>Not accepted:</strong> ' + (shortText || 'Not equivalent.') + '</div>';
            console.log('[SBAI] rendered verdict: Not accepted', { text: shortText });
          }
          const card = document.getElementById('plead-result');
          if (card && card.classList.contains('d-none')) {
            card.classList.remove('d-none');
            console.log('[SBAI] ensured verdict card visible after render');
          }
          console.log('[SBAI] verdict content length', content.textContent.length);

          // Inline verdict inside the AI Help header area
          const inline = document.getElementById('plead-inline');
          const inlineAlert = document.getElementById('plead-inline-alert');
          if (inline && inlineAlert) {
            inline.classList.remove('d-none');
            inlineAlert.classList.remove('alert-success', 'alert-warning', 'alert-secondary');
            inlineAlert.classList.add(equivalent ? 'alert-success' : 'alert-warning');
            inlineAlert.innerHTML = (equivalent ? '<strong>Accepted:</strong> ' : '<strong>Not accepted:</strong> ') + (shortText || (equivalent ? 'Equivalent answer.' : 'Not equivalent.'));
            console.log('[SBAI] inline verdict shown');
          } else {
            console.warn('[SBAI] inline verdict elements not found');
          }
        }

        function sbIsMcqCurrent() {
          try { return !!(window.room && room.tossup && room.tossup.is_mcq); } catch (_) { return false; }
        }

        function sbWasUserIncorrect() {
          try { return !!(window.room && room.previous && room.previous.isCorrect === false); } catch (_) { return false; }
        }

        function sbHasUserAnswer() {
          const ua = (document.getElementById('user-answer')?.textContent || '').replace(/^YOUR ANSWER:\s*/i, '').trim();
          return ua.length > 0;
        }

        function sbUpdatePleadButtonVisibility() {
          const btn = document.getElementById('plead-equivalence');
          if (!btn) return;
          // Show only for FRQ (not MCQ), user was marked incorrect, and they have an answer
          if (!sbIsMcqCurrent() && sbWasUserIncorrect() && sbHasUserAnswer()) {
            btn.classList.remove('d-none');
            btn.disabled = false;
            btn.textContent = 'I was correct';
          } else {
            btn.classList.add('d-none');
          }
        }

        async function sbRunPleadEquivalence() {
          const btn = document.getElementById('plead-equivalence');
          try {
            const qEl = document.getElementById('question');
            const aEl = document.getElementById('answer-display');
            const uEl = document.getElementById('user-answer');
            if (!aEl || !uEl) { console.error('[SBAI] Missing answer elements', { hasAnswerEl: !!aEl, hasUserEl: !!uEl }); return; }
            const question = (qEl?.textContent || '').trim();
            const rawCorrect = (aEl.textContent || '').trim();
            const correctAnswer = rawCorrect.replace(/^ANSWER:\\s*/i, '');
            const userAnswer = (uEl.textContent || '').replace(/^YOUR ANSWER:\\s*/i, '').trim();
            if (!userAnswer || !correctAnswer) {
              console.warn('[SBAI] Missing values before plead', { userAnswer, correctAnswer });
              sbShowPlead();
              const content = document.getElementById('plead-result-content');
              if (content) content.innerHTML = '<div class="alert alert-warning mb-0">Missing answer(s). Try revealing the answer first.</div>';
              return;
            }
            console.log('[SBAI] plead start', { qLen: question.length, correctAnswer, userAnswer, category: sbGetCurrentCategory() });
            sbShowPlead();
            sbShowPleadLoading();
            if (btn) btn.disabled = true;
            const resp = await fetch('/api/ai-help/equivalence', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ question, correctAnswer, userAnswer, category: sbGetCurrentCategory() })
            });
            console.log('[SBAI] plead response', { ok: resp.ok, status: resp.status, ct: resp.headers.get('content-type') });
            const ct = resp.headers.get('content-type') || '';
            if (!resp.ok) {
              const err = ct.includes('application/json') ? (await resp.json()) : { error: await resp.text() };
              throw new Error(err.error || 'Equivalence check failed');
            }
            if (!ct.includes('application/json')) {
              const text = await resp.text();
              throw new Error('Unexpected non-JSON response: ' + text.slice(0, 60));
            }
            const data = await resp.json();
            console.log('[SBAI] plead parsed', data);
            sbHidePleadLoading();
            console.log('[SBAI] rendering verdict to DOM');
            sbRenderPleadResult(!!data.equivalent, data.justification || data.rationale || '');

            if (data.equivalent) {
              const tossupId = (window.room?.previous?.tossup?._id) || (window.room?.tossup?._id) || null;
              const wasAlreadyCorrected = tossupId && window.sbCorrectedTossupIds?.has(tossupId);
              // Credit the user once if they were previously incorrect
              try {
                if (!wasAlreadyCorrected && window.room && room.previous && room.previous.isCorrect === false) {
                  room.previous.isCorrect = true;
                  const player = window.room?.players?.user;
                  if (player) {
                    const isTossup = room.previous?.tossup?.isTossup === true;
                    const increment = isTossup ? 4 : 10;
                    const currentScore = (typeof player.score === 'number' && !Number.isNaN(player.score)) ? player.score : 0;
                    player.score = currentScore + increment;
                    if (typeof window.updateStatDisplay === 'function') {
                      window.updateStatDisplay(player);
                    }
                  } else if (typeof window.updateStatDisplay === 'function') {
                    window.updateStatDisplay();
                  }
                }
              } catch (_) {}
              if (btn) {
                btn.textContent = 'Accepted';
                // Hide the button once credit has been granted to avoid duplicates
                btn.classList.add('d-none');
              }

              const statSubject = window.room?.previous?.tossup?.subject || window.room?.tossup?.subject || '';
              const previousState = window.room?.previous;
              const isTossup = (previousState?.tossup?.isTossup ?? window.room?.tossup?.isTossup) === true;
              const buzzedEarly = Boolean(isTossup && previousState?.endOfQuestion === false);
              const wasNeg = buzzedEarly && previousState?.isCorrect === false;
              const shouldSped = buzzedEarly && isTossup;
              if (typeof window.sbRecordSessionStat === 'function') {
                window.sbRecordSessionStat({
                  subject: statSubject,
                  adjustment: window.sbSessionStatWrongToCorrect || 'wrong-to-correct',
                  tossupId,
                  wasNeg,
                  shouldSped
                });
              }
              if (typeof window.sbTrackSubjectStatAdjustment === 'function') {
                window.sbTrackSubjectStatAdjustment(statSubject, {
                  correct: 1,
                  wrong: -1,
                  sped: shouldSped ? 1 : 0,
                  negs: wasNeg ? -1 : 0
                });
              }
              window.refreshScienceBowlSubjectStats?.();
            } else {
              if (btn) btn.textContent = 'Not accepted';
            }
          } catch (e) {
            console.error('[SBAI] Plead error:', e);
            sbHidePleadLoading();
            const content = document.getElementById('plead-result-content');
            if (content) content.innerHTML = '<div class="alert alert-danger"><strong>Error:</strong> ' + (e?.message || e) + '</div>';
          } finally {
            if (btn) btn.disabled = false;
          }
        }

        function sbRenderPractice(problems) {
          const content = document.getElementById('extra-practice-content');
          if (!content) return;
          if (!Array.isArray(problems) || problems.length === 0) {
            content.innerHTML = '<div class="alert alert-warning">No practice problems returned.</div>';
            return;
          }
          const items = problems.map((p, idx) => {
            const q = p.question || '';
            const a = p.answer || '';
            const ex = p.explanation || '';
            return `<li class="mb-3">
              <div><strong>Q${idx + 1}.</strong> ${q}</div>
              <div class="mt-1"><span class="fw-semibold">Answer:</span> ${a}</div>
              <div class="mt-1"><span class="fw-semibold">Explanation:</span> ${ex}</div>
            </li>`;
          }).join('');
          content.innerHTML = `<ol class="mb-0 ps-3">${items}</ol>`;
        }

        function sbRenderSuggestions(suggestions) {
          const content = document.getElementById('suggested-reading-content');
          if (!content) return;
          if (!Array.isArray(suggestions) || suggestions.length === 0) {
            content.innerHTML = '<div class="alert alert-warning">No suggestions returned.</div>';
            return;
          }
          const items = suggestions.map((s) => {
            const title = s.title || 'Resource';
            const type = s.type ? `<span class="badge bg-secondary ms-2">${s.type}</span>` : '';
            const notes = s.notes ? `<div class="small text-muted">${s.notes}</div>` : '';
            const link = s.link ? `<a href="${s.link}" target="_blank" rel="noopener">${s.link}</a>` : '';
            return `<li class="mb-2"><strong>${title}</strong> ${type}<br>${notes}${link ? '<div>' + link + '</div>' : ''}</li>`;
          }).join('');
          content.innerHTML = `<ul class="mb-0 ps-3">${items}</ul>`;
        }

        function sbGetCurrentCategory() {
          try {
            if (window.room && room.categoryManager && room.categoryManager.categories?.length) {
              return room.categoryManager.categories[0];
            }
          } catch (_) {}
          const checked = document.querySelector('.category-checkbox:checked');
          return checked?.id || 'Science';
        }

        async function sbGetAIExplanation() {
          try {
            const qEl = document.getElementById('question');
            const aEl = document.getElementById('answer-display');
            if (!qEl || !aEl) { console.error('[SBAI] question/answer elements missing'); return; }
            const question = (qEl.textContent || '').trim();
            const rawAnswer = (aEl.textContent || '').trim();
            const answer = rawAnswer.replace(/^ANSWER:\\s*/i, '');
            // Pull MCQ options from room state if present
            let isMcq = false;
            let options = undefined;
            try {
              isMcq = !!(window.room && room.tossup && room.tossup.is_mcq && Array.isArray(room.tossup.options));
              options = isMcq ? room.tossup.options : undefined;
            } catch (_) {}
            if (!question || !answer) {
              console.warn('[SBAI] Missing question or answer. q:', !!question, 'a:', !!answer);
              return;
            }
            sbShowLoading();
            sbShowAIExplanation();
            const resp = await fetch('/api/ai-help/explain', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                question, 
                answer, 
                category: sbGetCurrentCategory(), 
                isMcq, 
                options,
                userAnswer: (document.getElementById('user-answer')?.textContent || '').replace(/^YOUR ANSWER:\\s*/i, '').trim(),
                userIsCorrect: (window.room && room.previous && room.previous.isCorrect === true)
              })
            });
            if (!resp.ok) {
              const err = await resp.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to get AI explanation');
            }
            const ct = resp.headers.get('content-type') || '';
            if (!ct.includes('application/json')) {
              const text = await resp.text();
              throw new Error('Unexpected non-JSON response: ' + text.slice(0, 60));
            }
            const data = await resp.json();
            sbHideLoading();
            if (!data?.explanation) {
              sbDisplayExplanation('<div class="alert alert-warning">No explanation returned.</div>');
            } else {
              sbDisplayExplanation(data.explanation);
            }
          } catch (e) {
            console.error('[SBAI] AI explanation error:', e);
            sbHideLoading();
            sbDisplayExplanation('<div class="alert alert-danger"><strong>Error:</strong> ' + (e?.message || e) + '</div>');
          }
        }

        async function sbGetSuggestedReading() {
          try {
            const qEl = document.getElementById('question');
            const aEl = document.getElementById('answer-display');
            if (!qEl || !aEl) { console.error('[SBAI] question/answer elements missing'); return; }
            const question = (qEl.textContent || '').trim();
            const rawAnswer = (aEl.textContent || '').trim();
            const answer = rawAnswer.replace(/^ANSWER:\\s*/i, '');
            if (!question) { console.warn('[SBAI] Missing question text'); return; }
            sbShowSuggested();
            sbShowSuggestedLoading();
            const resp = await fetch('/api/ai-help/suggest-reading', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ question, answer, category: sbGetCurrentCategory() })
            });
            if (!resp.ok) {
              const err = await resp.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to get suggestions');
            }
            const ct = resp.headers.get('content-type') || '';
            if (!ct.includes('application/json')) {
              const text = await resp.text();
              throw new Error('Unexpected non-JSON response: ' + text.slice(0, 60));
            }
            const data = await resp.json();
            sbHideSuggestedLoading();
            sbRenderSuggestions(data.suggestions);
          } catch (e) {
            console.error('[SBAI] Suggested reading error:', e);
            sbHideSuggestedLoading();
            const content = document.getElementById('suggested-reading-content');
            if (content) content.innerHTML = '<div class="alert alert-danger"><strong>Error:</strong> ' + (e?.message || e) + '</div>';
          }
        }

        async function sbGetExtraPractice() {
          try {
            const qEl = document.getElementById('question');
            const aEl = document.getElementById('answer-display');
            if (!qEl || !aEl) { console.error('[SBAI] question/answer elements missing'); return; }
            const question = (qEl.textContent || '').trim();
            const rawAnswer = (aEl.textContent || '').trim();
            const answer = rawAnswer.replace(/^ANSWER:\\s*/i, '');
            if (!question) { console.warn('[SBAI] Missing question text'); return; }
            sbShowPractice();
            sbShowPracticeLoading();
            const resp = await fetch('/api/ai-help/extra-practice', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ question, answer, category: sbGetCurrentCategory() })
            });
            if (!resp.ok) {
              const err = await resp.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to get practice questions');
            }
            const ct = resp.headers.get('content-type') || '';
            if (!ct.includes('application/json')) {
              const text = await resp.text();
              throw new Error('Unexpected non-JSON response: ' + text.slice(0, 60));
            }
            const data = await resp.json();
            sbHidePracticeLoading();
            sbRenderPractice(data.problems);
          } catch (e) {
            console.error('[SBAI] Extra practice error:', e);
            sbHidePracticeLoading();
            const content = document.getElementById('extra-practice-content');
            if (content) content.innerHTML = '<div class="alert alert-danger"><strong>Error:</strong> ' + (e?.message || e) + '</div>';
          }
        }

        function sbInitAIHelp() {
          if (window.__sbAiInited) return;
          window.__sbAiInited = true;
          // Delegated click for AI controls and Start/Next clearing
          document.addEventListener('click', (e) => {
            const btn = e.target && e.target.closest && e.target.closest('#get-ai-help');
            if (btn) { e.preventDefault(); sbGetAIExplanation(); }
            const btn2 = e.target && e.target.closest && e.target.closest('#get-suggested-reading');
            if (btn2) { e.preventDefault(); sbGetSuggestedReading(); }
            const btn3 = e.target && e.target.closest && e.target.closest('#get-extra-practice');
            if (btn3) { e.preventDefault(); sbGetExtraPractice(); }
            const plead = e.target && e.target.closest && e.target.closest('#plead-equivalence');
            if (plead) { console.log('[SBAI] plead button clicked'); e.preventDefault(); sbRunPleadEquivalence(); }
            const start = e.target && e.target.closest && e.target.closest('#start');
            if (start) { sbHideAIHelpSection(); }
          });

          // Also clear on keyboard shortcuts for start/next
          document.addEventListener('keydown', (e) => {
            if (e.target && e.target.tagName === 'INPUT') return;
            if (e.key === 'n' || e.key === 's') {
              sbHideAIHelpSection();
            }
          });
          // Observe answer reveal
          const aEl = document.getElementById('answer-display');
          if (aEl) {
            const obs = new MutationObserver(() => {
              const t = (aEl.textContent || '').trim();
              if (t) {
                console.log('[SBAI] answer-display mutated, text present. Showing AI section and updating plead visibility.');
                sbShowAIHelpSection();
                // Do not auto-fetch here; wait for user click
                sbUpdatePleadButtonVisibility();
              }
            });
            obs.observe(aEl, { childList: true, subtree: true, characterData: true });
          }
          // Ensure hidden on load
          sbHideAIHelpSection();
          console.log('[SBAI] Inline AI Help initialized');
        }

        // Expose for manual testing
        window.SBAI = {
          show: sbShowAIHelpSection,
          hide: sbHideAIHelpSection,
          explain: sbGetAIExplanation,
          plead: sbRunPleadEquivalence,
          init: sbInitAIHelp
        };

        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', sbInitAIHelp);
        } else {
          sbInitAIHelp();
        }
      })();
    </script>
    <script>
      (function initTopicImprovementTracker () {
        const STORAGE_KEY = 'singleplayer-science-bowl-topics-needed';
        const TOPICS_COLLAPSE_KEY = 'singleplayer-science-bowl-topics-collapsed';
        const MAX_TOPICS = 20;
        const state = {
          topics: [],
          inFlight: new Set(),
          topicsCollapsed: false
        };

        const els = {
          list: document.getElementById('topics-needed-list'),
          empty: document.getElementById('topics-needed-empty'),
          count: document.getElementById('topics-needed-count'),
          clear: document.getElementById('topics-needed-clear'),
          refresh: document.getElementById('topics-needed-refresh'),
          collapseToggle: document.getElementById('topics-collapse-toggle'),
          container: document.getElementById('topics-needed-section')
        };
        const storedCollapsed = window.localStorage.getItem(TOPICS_COLLAPSE_KEY);
        state.topicsCollapsed = storedCollapsed === 'true';

        function escapeHtml (str = '') {
          return str.replace(/[&<>"']/g, (ch) => ({
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          }[ch] || ch));
        }

        function stripHtml (str = '') {
          return str.replace(/<[^>]*>/g, ' ');
        }

        function truncateText (text = '', maxLen = 140) {
          if (text.length <= maxLen) return text;
          return text.slice(0, maxLen - 1).trimEnd() + '...';
        }

        function buildFingerprint (question = '', answer = '') {
          return `${question.trim().toLowerCase()}|${answer.trim().toLowerCase()}`.slice(0, 400);
        }

        function enforceWordLimit (text = '', minWords = 3, maxWords = 5) {
          const words = text.split(/\s+/).filter(Boolean);
          if (words.length === 0) return '';
          const limited = words.slice(0, maxWords);
          if (limited.length < minWords && words.length >= minWords) {
            return words.slice(0, minWords).join(' ');
          }
          return limited.join(' ');
        }

        function countWords (text = '') {
          if (!text || !text.trim()) return 0;
          return text.trim().split(/\s+/).length;
        }

        function formatSummaryText (raw, category, answer) {
          const fallbackSource = `${category || 'Science'} ${answer || 'core concept'} focus`.trim();
          const fallback = enforceWordLimit(fallbackSource);
          if (!raw || typeof raw !== 'string') return fallback;
          const clean = raw.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
          if (!clean) return fallback;
          const limited = enforceWordLimit(clean);
          if (countWords(limited) < 3) {
            return fallback;
          }
          return limited || fallback;
        }

        function applyTopicsCollapsedState () {
          if (els.container) {
            els.container.classList.toggle('collapsed', state.topicsCollapsed);
          }
          if (els.collapseToggle) {
            els.collapseToggle.setAttribute('aria-expanded', (!state.topicsCollapsed).toString());
            els.collapseToggle.title = state.topicsCollapsed ? 'Expand topics list' : 'Collapse topics list';
          }
        }

        function setTopicsCollapsed (collapsed) {
          state.topicsCollapsed = collapsed;
          try {
            window.localStorage.setItem(TOPICS_COLLAPSE_KEY, collapsed ? 'true' : 'false');
          } catch (err) {
            console.warn('[SB Topics] Failed to persist collapse state', err);
          }
          applyTopicsCollapsedState();
        }

        function loadFromStorage () {
          try {
            const stored = JSON.parse(window.localStorage.getItem(STORAGE_KEY) || '[]');
            if (Array.isArray(stored)) {
              state.topics = stored.slice(0, MAX_TOPICS).map((entry) => ({
                ...entry,
                status: entry.status === 'ready' ? 'ready' : (entry.status === 'error' ? 'error' : 'pending'),
                summary: entry.summary || 'Generating topic summary...'
              }));
            }
          } catch (err) {
            console.warn('[SB Topics] Failed to load stored topics', err);
            state.topics = [];
          }
        }

        function saveToStorage () {
          try {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(state.topics.slice(0, MAX_TOPICS)));
          } catch (err) {
            console.warn('[SB Topics] Failed to persist topics', err);
          }
        }

        function renderList () {
          if (!els.list || !els.empty || !els.count) return;
          const hasTopics = state.topics.length > 0;
          els.empty.classList.toggle('d-none', hasTopics);
          els.list.classList.toggle('d-none', !hasTopics);
          if (!hasTopics) {
            els.count.textContent = 'Log of AI summaries for missed tossups.';
            els.list.innerHTML = '';
            return;
          }
          els.count.textContent = `${state.topics.length} topic${state.topics.length === 1 ? '' : 's'} logged`;
          const items = state.topics.map((entry) => {
            const summaryHtml = entry.status === 'pending'
              ? '<span class="text-muted"><span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Summarizing...</span>'
              : entry.status === 'error'
                ? `<span class="text-danger">${escapeHtml(entry.summary)}</span>`
                : `<span class="topic-summary-text">${escapeHtml(entry.summary)}</span>`;
            const metaParts = [];
            if (entry.category) metaParts.push(escapeHtml(entry.category));
            if (entry.correctAnswer) metaParts.push(`Correct: ${escapeHtml(entry.correctAnswer)}`);
            if (entry.userAnswer) metaParts.push(`Your answer: ${escapeHtml(entry.userAnswer)}`);
            const metaHtml = metaParts.length ? `<div class="small text-muted mt-1">${metaParts.join('  ')}</div>` : '';
            const questionHtml = entry.questionSnippet
              ? `<div class="small text-muted">Q: ${escapeHtml(entry.questionSnippet)}</div>`
              : '';
            const retryButton = entry.status === 'error'
              ? `<button type="button" class="btn btn-sm btn-outline-secondary me-2" data-topic-retry="${entry.id}">
                    <i class="bi bi-arrow-repeat"></i>
                    Retry
                 </button>`
              : '';
            return `<li class="topic-item" data-topic-id="${entry.id}">
              <div class="d-flex align-items-start">
                <div class="flex-grow-1">
                  <div>${summaryHtml}</div>
                  ${metaHtml}
                  ${questionHtml}
                </div>
                <div class="ms-3 text-nowrap">
                  ${retryButton}
                  <button type="button" class="btn btn-sm btn-outline-danger" data-topic-remove="${entry.id}" aria-label="Remove topic summary">
                    <i class="bi bi-x-lg"></i>
                  </button>
                </div>
              </div>
            </li>`;
          }).join('');
          els.list.innerHTML = items;
        }

        async function requestTopicSummary ({ question, answer, category }) {
          const resp = await fetch('/api/ai-help/topic-summary', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              question,
              answer,
              category
            })
          });
          const contentType = resp.headers.get('content-type') || '';
          const body = contentType.includes('application/json') ? await resp.json() : await resp.text();
          if (!resp.ok) {
            const errMessage = typeof body === 'string'
              ? body.slice(0, 120)
              : (body?.error || 'Failed to generate topic summary');
            throw new Error(errMessage);
          }
          const summary = typeof body === 'string' ? body : body.summary;
          return formatSummaryText(summary, category, answer);
        }

        async function runSummaryForEntry (entry) {
          if (!entry || state.inFlight.has(entry.id)) return;
          state.inFlight.add(entry.id);
          const questionForSummary = entry.questionFull || entry.questionSnippet || '';
          if (!questionForSummary) {
            entry.summary = 'Summary unavailable: missing question text';
            entry.status = 'error';
            state.inFlight.delete(entry.id);
            renderList();
            saveToStorage();
            return;
          }
          entry.status = 'pending';
          entry.summary = 'Generating topic summary...';
          renderList();
          saveToStorage();
          try {
            const summary = await requestTopicSummary({
              question: questionForSummary,
              answer: entry.correctAnswer,
              category: entry.category
            });
            entry.summary = summary;
            entry.status = 'ready';
          } catch (error) {
            entry.summary = `Summary unavailable: ${error?.message || 'Unknown error'}`;
            entry.status = 'error';
          } finally {
            state.inFlight.delete(entry.id);
            saveToStorage();
            renderList();
          }
        }

        function hasExistingEntry ({ tossupId, fingerprint }) {
          return state.topics.some((entry) => {
            if (tossupId && entry.tossupId && entry.tossupId === tossupId) return true;
            if (fingerprint && entry.fingerprint && entry.fingerprint === fingerprint) return true;
            return false;
          });
        }

        async function trackWrongAnswer ({ questionText, correctAnswer, category, tossupId, userAnswer }) {
          const cleanedQuestion = stripHtml(questionText || '').replace(/\s+/g, ' ').trim();
          const question = truncateText(cleanedQuestion, 600);
          const answer = (correctAnswer || '').toString().trim();
          if (!question || !answer) {
            return;
          }
          const fingerprint = buildFingerprint(cleanedQuestion, answer);
          if (hasExistingEntry({ tossupId, fingerprint })) {
            return;
          }
          const entry = {
            id: `${Date.now()}-${Math.random().toString(36).slice(2, 7)}`,
            tossupId: tossupId || null,
            fingerprint,
            category: (category || 'Science').toUpperCase(),
            correctAnswer: answer,
            userAnswer: (userAnswer || '').trim(),
            questionSnippet: truncateText(cleanedQuestion, 140),
            questionFull: cleanedQuestion,
            summary: 'Generating topic summary...',
            status: 'pending',
            timestamp: Date.now()
          };
          state.topics.unshift(entry);
          if (state.topics.length > MAX_TOPICS) {
            state.topics.splice(MAX_TOPICS);
          }
          saveToStorage();
          renderList();
          runSummaryForEntry(entry);
        }

        function removeEntry (id) {
          const idx = state.topics.findIndex((entry) => entry.id === id);
          if (idx === -1) return;
          state.topics.splice(idx, 1);
          saveToStorage();
          renderList();
        }

        async function retryEntry (id) {
          const entry = state.topics.find((item) => item.id === id);
          if (!entry) return;
          runSummaryForEntry(entry);
        }

        async function refreshSummaries () {
          for (const entry of state.topics) {
            if (entry.status !== 'ready') {
              await runSummaryForEntry(entry);
            }
          }
        }

        loadFromStorage();
        renderList();
        applyTopicsCollapsedState();

        els.clear?.addEventListener('click', () => {
          if (state.topics.length === 0) return;
          if (window.confirm('Clear all tracked topics? This cannot be undone.')) {
            state.topics = [];
            saveToStorage();
            renderList();
          }
        });

        els.collapseToggle?.addEventListener('click', () => {
          setTopicsCollapsed(!state.topicsCollapsed);
        });

        els.refresh?.addEventListener('click', () => {
          window.scrollTo({ top: 0, behavior: 'smooth' });
          refreshSummaries();
        });

        els.list?.addEventListener('click', (event) => {
          const target = event.target.closest('[data-topic-remove], [data-topic-retry]');
          if (!target) return;
          const removeId = target.getAttribute('data-topic-remove');
          const retryId = target.getAttribute('data-topic-retry');
          if (removeId) {
            removeEntry(removeId);
          } else if (retryId) {
            retryEntry(retryId);
          }
        });

        window.sbTopicTracker = {
          trackWrongAnswer,
          retry: retryEntry,
          refresh: refreshSummaries
        };
      })();
    </script>
    <script type="module">
        import { validateAnswer, formatValidationResult } from './answer-validator.js';
        const usingModernClient = window.__sbModernScienceBowlClient === true;
        const legacyHandlersActive = () => window.__sbModernHandlersReady !== true;

        // Text-to-speech shared state (declared early so other handlers can reference safely)
        let speechSynthesis = window.speechSynthesis;
        let speechPreferenceEnabled = false;
        let speechEnabled = false;
        let currentUtterance = null;
        let originalWordIndex = 0;
        let isPaused = false;
        const SPEECH_RATE_MIN = 0.6;
        const SPEECH_RATE_MAX = 1.7;
        const ANSWER_CHOICE_GAP_SLOW_MS = 1400;
        const ANSWER_CHOICE_GAP_FAST_MS = 350;
        let speechSegmentTimeout = null;
        let speechSequenceActive = false;
        let speechHandledThisQuestion = false;
        let audioNoticeVisible = false;
        let audioLockApplied = false;
        let audioReadingActive = false;
        let currentSpeechQuestionKey = null;
        let completedSpeechQuestionKey = null;
        let lastQuestionKeySeen = null;
        
        // Handle buzz and answer submission
        const buzzButton = document.getElementById('buzz');
        if (buzzButton) {
            buzzButton.addEventListener('click', function() {
                console.log('Buzz button clicked');
                if (!window.room) {
                    console.error('Room not initialized');
                    return;
                }
                
                // Stop any ongoing speech
                if (speechSynthesis.speaking) {
                    console.log('Stopping speech synthesis on buzz');
                    speechSynthesis.cancel();
                    currentUtterance = null;
                    isPaused = false;
                    clearAudioReadingNotice({ unlockQuestion: true });
                }
                
                // Only send the buzz message if the modern handlers are not active
                if (legacyHandlersActive()) {
                    window.room.message('user', { type: 'buzz' });
                }
            });
        }

        // Handle start/next button (legacy fallback only)
        const legacyStartButton = document.getElementById('start');
        if (legacyStartButton) {
            legacyStartButton.addEventListener('click', function() {
                if (!legacyHandlersActive()) {
                    return;
                }

                console.log('Start/Next button clicked');
                if (!window.room) {
                    console.error('Room not initialized');
                    return;
                }
                
                // Reset all states
                window.room.buzzedIn = null;
                window.room.buzzes = [];
                window.room.tossupProgress = 'READING';
                window.room.paused = false;
                
                // Reset UI elements
                const buzzButtonEl = document.getElementById('buzz');
                const pauseButton = document.getElementById('pause');
                const answerInput = document.getElementById('answer-input');
                const answerInputGroup = document.getElementById('answer-input-group');
                const toggleCorrectButton = document.getElementById('toggle-correct');
                const answerDisplay = document.getElementById('answer-display');
                const userAnswer = document.getElementById('user-answer');
                const answer = document.getElementById('answer');
                
                // Enable/disable appropriate buttons
                buzzButtonEl.disabled = false;
                buzzButtonEl.textContent = 'Buzz';
                pauseButton.disabled = false;
                pauseButton.textContent = 'Pause';
                
                // Clear and hide answer input
                answerInput.value = '';
                if (answerInputGroup) {
                    answerInputGroup.classList.add('d-none');
                }
                
                // Hide toggle correct button and clear answer displays
                if (toggleCorrectButton) {
                    toggleCorrectButton.classList.add('d-none');
                }
                if (answerDisplay) { answerDisplay.innerHTML = ''; }
                if (userAnswer) { userAnswer.innerHTML = ''; }
                if (answer) { answer.innerHTML = ''; }
                
                // Ensure categories are synced
                window.room.query.subjects = window.room.categoryManager.categories;
                console.log('Starting with categories:', window.room.categoryManager.categories);
                
                // Start new question
                window.room.message('user', { type: 'start' });
            });
        }

        // Add keyboard shortcuts: space = Buzz, n = Start/Next, p = Pause/Resume (legacy only)
        document.addEventListener('keydown', (e) => {
            if (!legacyHandlersActive()) {
                return;
            }
            const tag = (e.target.tagName || '').toUpperCase();
            const isTyping = tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable;
            if (isTyping) return;

            // Space => Buzz
            if (e.key === ' ' || e.code === 'Space') {
                e.preventDefault();
                const buzzBtn = document.getElementById('buzz');
                if (buzzBtn && !buzzBtn.disabled) {
                    console.log('Space pressed: triggering Buzz');
                    buzzBtn.click();
                }
                return;
            }

            // n/N => Start/Next
            if (e.key && e.key.toLowerCase() === 'n') {
                const startBtn = document.getElementById('start');
                if (startBtn && !startBtn.disabled) {
                    console.log('N pressed: triggering Start/Next');
                    startBtn.click();
                }
                return;
            }

            // p/P => Pause/Resume
            if (e.key && e.key.toLowerCase() === 'p') {
                e.preventDefault();
                console.log('P pressed: toggling Pause/Resume');
                handlePause();
                return;
            }
        });

        // Handle answer submission (legacy fallback only)
        document.getElementById('answer-form').addEventListener('submit', function(event) {
            event.preventDefault();
            event.stopPropagation();
            
            if (!legacyHandlersActive()) {
                return;
            }

            const answer = document.getElementById('answer-input').value;
            console.log('Answer submitted:', answer);
            
            if (!window.room) {
                console.error('Room not initialized');
                return;
            }

            // Get the current question's correct answer
            const correctAnswer = window.room.tossup?.answer;
            console.log('Attempting to get correct answer:', {
                correctAnswer,
                tossup: window.room.tossup
            });

            if (!correctAnswer) {
                console.error('No correct answer available for current question');
                return;
            }
            
            // Get the current strictness setting (default to 7 if control is absent)
            const strictnessEl = document.getElementById('set-strictness');
            const strictness = strictnessEl ? (parseInt(strictnessEl.value) || 7) : 7;
            
            // Validate the answer
            const validationResult = validateAnswer(answer, correctAnswer, strictness);
            console.log('Answer validation result:', validationResult);
            
            // If answer is correct, update the UI score (legacy fallback only)
            if (validationResult.isCorrect) {
                const statline = document.getElementById('statline');
                const isTossup = window.room?.tossup?.isTossup === true;
                const increment = isTossup ? 4 : 10;
                const currentScore = statline ? (parseInt(statline.textContent.split(': ')[1]) || 0) : 0;
                const newScore = currentScore + increment;
                if (statline) {
                    statline.textContent = `SCORE: ${newScore}`;
                }
            }
            
            // Call revealAnswer with the necessary data
            revealAnswer({
                type: 'reveal-answer',
                question: window.room.questionSplit.join(' '),
                answer: answer,
                correctAnswer: correctAnswer
            });
            
            // Clear and hide input
            document.getElementById('answer-input').value = '';
            document.getElementById('answer-input-group').classList.add('d-none');
            
            // Send answer to room with validation result
            window.room.message('user', { 
                type: 'give-answer', 
                givenAnswer: answer,
                isCorrect: validationResult.isCorrect,
                matchType: validationResult.matchType
            });
        });

        // Initialize room state (legacy only)
        function initializeRoomState() {
            if (!legacyHandlersActive()) {
                return;
            }
            if (!window.room) {
                console.error('Room not initialized');
                return;
            }

            // Store the original emitMessage method
            const originalEmitMessage = window.room.emitMessage;
            
            // Override the emitMessage method to handle button states
            window.room.emitMessage = function(message) {
                console.log('Room emitting message:', message);
                
                // Store the question object when it's emitted
                if (message.type === 'question') {
                    console.log('Storing question object:', message.question);
                    this.tossup = message.question;
                    window.room.tossup = message.question;
                }
                
                // Handle reveal-answer message before calling original method
                if (message.type === 'reveal-answer') {
                    console.log('Handling reveal-answer message:', message);
                    revealAnswer(message);
                    return;
                }
                
                // Call the original method for all other message types
                originalEmitMessage.call(this, message);
            };
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing room state...');
            initializeRoomState();
        });

        // Text-to-speech functionality

        function getReadingSpeedSetting() {
            const slider = document.getElementById('reading-speed');
            const sliderValue = slider ? parseInt(slider.value, 10) : NaN;
            if (!Number.isNaN(sliderValue)) {
                return sliderValue;
            }
            const roomSpeed = window.room?.settings?.readingSpeed;
            if (typeof roomSpeed === 'number' && !Number.isNaN(roomSpeed)) {
                return roomSpeed;
            }
            return 50;
        }

        function calculateSpeechRate(readingSpeed) {
            const clamped = Math.max(0, Math.min(100, Number(readingSpeed) || 50));
            const normalized = (clamped - 50) / 50;
            if (normalized >= 0) {
                return 1 + normalized * (SPEECH_RATE_MAX - 1);
            }
            return 1 + normalized * (1 - SPEECH_RATE_MIN);
        }

        function calculateAnswerChoiceGap(readingSpeed) {
            const clamped = Math.max(0, Math.min(100, Number(readingSpeed) || 50));
            const ratio = 1 - (clamped / 100);
            return Math.round(ANSWER_CHOICE_GAP_FAST_MS + ratio * (ANSWER_CHOICE_GAP_SLOW_MS - ANSWER_CHOICE_GAP_FAST_MS));
        }

        function getSpeechTimingSettings() {
            const speed = getReadingSpeedSetting();
            return {
                speed,
                rate: calculateSpeechRate(speed),
                answerGapMs: calculateAnswerChoiceGap(speed)
            };
        }

        // Function to stop current speech
        function stopCurrentSpeech() {
            if (currentUtterance) {
                console.log('Stopping current speech');
                speechSynthesis.cancel();
                currentUtterance = null;
                isPaused = false;
            }
            if (speechSegmentTimeout) {
                clearTimeout(speechSegmentTimeout);
                speechSegmentTimeout = null;
            }
            speechSequenceActive = false;
            speechHandledThisQuestion = false;
            audioReadingActive = false;
        }

        function playSpeechSegments(segments, onComplete, speechRate = 1.0) {
            if (!Array.isArray(segments) || segments.length === 0) {
                if (typeof onComplete === 'function') {
                    onComplete();
                }
                return;
            }

            stopCurrentSpeech();
            speechSequenceActive = true;
            let segmentIndex = 0;

            const finishSequence = () => {
                if (!speechSequenceActive) { return; }
                speechSequenceActive = false;
                if (speechSegmentTimeout) {
                    clearTimeout(speechSegmentTimeout);
                    speechSegmentTimeout = null;
                }
                audioReadingActive = false;
                if (currentSpeechQuestionKey) {
                    completedSpeechQuestionKey = currentSpeechQuestionKey;
                }
                currentSpeechQuestionKey = null;
                clearAudioReadingNotice({ unlockQuestion: true });
                if (typeof onComplete === 'function') {
                    onComplete();
                }
            };

            const speakSegment = () => {
                if (!speechSequenceActive) { return; }
                if (segmentIndex >= segments.length) {
                    finishSequence();
                    return;
                }

                const { text, pauseAfter = 0 } = segments[segmentIndex];
                currentUtterance = new SpeechSynthesisUtterance(text);
                currentUtterance.rate = speechRate;

                currentUtterance.onend = () => {
                    if (!speechSequenceActive) { return; }
                    currentUtterance = null;
                    if (pauseAfter > 0) {
                        speechSegmentTimeout = setTimeout(() => {
                            speechSegmentTimeout = null;
                            segmentIndex++;
                            speakSegment();
                        }, pauseAfter);
                    } else {
                        segmentIndex++;
                        speakSegment();
                    }
                };

                currentUtterance.onerror = (event) => {
                    console.error('Speech synthesis error:', event);
                    if (!speechSequenceActive) { return; }
                    speechSequenceActive = false;
                    currentUtterance = null;
                    if (speechSegmentTimeout) {
                        clearTimeout(speechSegmentTimeout);
                        speechSegmentTimeout = null;
                    }
                    audioReadingActive = false;
                    if (currentSpeechQuestionKey) {
                        completedSpeechQuestionKey = currentSpeechQuestionKey;
                    }
                    currentSpeechQuestionKey = null;
                    clearAudioReadingNotice({ unlockQuestion: true });
                    if (typeof onComplete === 'function') {
                        onComplete();
                    }
                };

                isPaused = false;
                speechSynthesis.speak(currentUtterance);
            };

            speakSegment();
        }

        function applyAudioQuestionLock () {
            if (typeof window.lockQuestionRevealUntilAnswer === 'function') {
                window.lockQuestionRevealUntilAnswer();
                audioLockApplied = true;
            }
        }

        function releaseAudioQuestionLock () {
            if (!audioLockApplied) { return; }
            if (typeof window.unlockQuestionRevealUntilAnswer === 'function') {
                window.unlockQuestionRevealUntilAnswer();
            }
            audioLockApplied = false;
        }

        function getQuestionKeyFromContext (context) {
            const roomContext = context || window.room;
            const tossup = roomContext?.tossup;
            const idCandidate = tossup?._id ?? tossup?.id ?? tossup?.question_id ?? tossup?.tossup_id;
            if (idCandidate !== undefined && idCandidate !== null) {
                return `id:${idCandidate}`;
            }
            const tossupQuestion = typeof tossup?.question === 'string' ? tossup.question.trim() : '';
            if (tossupQuestion) {
                return `text:${tossupQuestion}`;
            }
            if (Array.isArray(roomContext?.questionSplit) && roomContext.questionSplit.length > 0) {
                return `split:${roomContext.questionSplit.join(' ')}`;
            }
            if (tossup) {
                if (!tossup.__audioQuestionKey) {
                    tossup.__audioQuestionKey = `generated-${Date.now()}-${Math.random().toString(36).slice(2)}`;
                }
                return tossup.__audioQuestionKey;
            }
            return null;
        }

        const AUDIO_NOTICE_DEFAULT = 'Audio question playing - listen for the question and answer choices.';

        function setAudioReadingNotice(message = AUDIO_NOTICE_DEFAULT, options = {}) {
            const { variant = 'info', showSpinner = true } = options;
            audioNoticeVisible = true;
            const spinnerHtml = showSpinner
                ? '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>'
                : '';
            const html = `<div class="alert alert-${variant} audio-reading-notice d-flex align-items-center gap-2 mb-0">${spinnerHtml}<span>${message}</span></div>`;
            if (typeof window.setQuestionLockOverlay === 'function') {
                window.setQuestionLockOverlay(html);
                return;
            }
            const questionElement = document.getElementById('question');
            if (questionElement) {
                questionElement.innerHTML = html;
            }
        }

        function clearAudioReadingNotice(options = {}) {
            const { unlockQuestion = false } = options;
            audioNoticeVisible = false;
            if (typeof window.clearQuestionLockOverlay === 'function') {
                window.clearQuestionLockOverlay();
            } else {
                const questionElement = document.getElementById('question');
                if (questionElement) {
                    questionElement.innerHTML = '';
                }
            }
            if (unlockQuestion) {
                releaseAudioQuestionLock();
            }
        }

        // Wait for room to be initialized
        function initializeSpeechSynthesis() {
            if (!window.room) {
                console.log('Room not initialized yet, retrying in 500ms...');
                setTimeout(initializeSpeechSynthesis, 500);
                return;
            }

            console.log('Room initialized, setting up speech synthesis...');
            
            // Store the original readQuestion method
            const originalReadQuestion = window.room.readQuestion;
            
            // Override the readQuestion method
            window.room.readQuestion = function(timestamp) {
                const questionKey = getQuestionKeyFromContext(this);
                const keyChanged = questionKey && questionKey !== lastQuestionKeySeen;
                if (keyChanged) {
                    lastQuestionKeySeen = questionKey;
                    completedSpeechQuestionKey = null;
                    speechHandledThisQuestion = false;
                    audioReadingActive = false;
                    currentSpeechQuestionKey = null;
                }

                console.log('readQuestion called with:', {
                    speechEnabled,
                    wordIndex: this.wordIndex,
                    tossupProgress: this.tossupProgress,
                    questionSplit: this.questionSplit?.length,
                    audioReadingActive,
                    questionKey,
                    completedSpeechQuestionKey
                });

                const atQuestionStart = this.wordIndex === 0;
                const alreadyCompleted = Boolean(questionKey && questionKey === completedSpeechQuestionKey);

                if ((atQuestionStart && !audioReadingActive) || keyChanged) {
                    speechHandledThisQuestion = false;
                }

                if (alreadyCompleted) {
                    return originalReadQuestion.call(this, timestamp);
                }

                const shouldStartSpeech = speechEnabled && !audioReadingActive && !speechHandledThisQuestion &&
                    (atQuestionStart || this.tossupProgress === 'READING');

                if (shouldStartSpeech) {
                    // Store the original word index when starting speech
                    originalWordIndex = 0;
                    speechHandledThisQuestion = true;
                    audioReadingActive = true;
                    setAudioReadingNotice();
                    applyAudioQuestionLock();

                    if (this.questionSplit && this.questionSplit.length > 0 && !speechSynthesis.speaking && !speechSequenceActive) {
                        currentSpeechQuestionKey = questionKey || currentSpeechQuestionKey || `generated-${Date.now()}-${Math.random().toString(36).slice(2)}`;
                        const fullQuestion = this.questionSplit.join(' ');
                        const answerChoices = Array.isArray(this.tossup?.options)
                            ? this.tossup.options
                                .map(option => typeof option === 'string' ? option.trim() : '')
                                .filter(option => option.length > 0)
                            : [];

                        const { rate: speechRate, answerGapMs } = getSpeechTimingSettings();
                        const speechSegments = [{
                            text: fullQuestion,
                            pauseAfter: answerChoices.length ? answerGapMs : 0
                        }];

                        answerChoices.forEach((choice, index) => {
                            speechSegments.push({
                                text: choice,
                                pauseAfter: (index === answerChoices.length - 1) ? 0 : answerGapMs
                            });
                        });

                        console.log('Starting speech with segments:', speechSegments);
                        playSpeechSegments(speechSegments, () => {
                            console.log('Speech ended');
                            this.wordIndex = originalWordIndex;
                            originalReadQuestion.call(this, timestamp);
                        }, speechRate);
                        return;
                    }

                    console.log('No question available for speech or speech already in progress');
                    audioReadingActive = false;
                    speechHandledThisQuestion = false;
                    currentSpeechQuestionKey = null;
                    clearAudioReadingNotice({ unlockQuestion: true });
                }

                if (speechEnabled && audioReadingActive) {
                    console.log('Audio reading in progress  deferring original reader');
                    return;
                }

                originalReadQuestion.call(this, timestamp);
            };

            // Store the original message method
            const originalMessage = window.room.message;
            
            // Override the message method
            window.room.message = function(type, data) {
                console.log('Message received:', { type, data });
                
                // Call the original method first
                originalMessage.call(this, type, data);
                
                // Handle different message types
                if (type === 'user') {
                    if (data.type === 'pause') {
                        // Handle pause/resume
                        if (speechEnabled) {
                            if (!isPaused) {
                                console.log('Pausing speech synthesis');
                                speechSynthesis.pause();
                                isPaused = true;
                                clearAudioReadingNotice();
                            } else {
                                console.log('Resuming speech synthesis');
                                speechSynthesis.resume();
                                isPaused = false;
                                setAudioReadingNotice();
                            }
                        }
                    } else if (data.type === 'start' || data.type === 'next') {
                        console.log('Start/Next button pressed');
                        // Stop current speech when starting/next question
                        speechEnabled = speechPreferenceEnabled;
                        speechHandledThisQuestion = false;
                        stopCurrentSpeech();
                        clearAudioReadingNotice({ unlockQuestion: true });
                    }
                }
            };
        }

        // Initialize speech synthesis when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing speech synthesis...');
            const toggle = document.getElementById('toggle-speech');
            speechPreferenceEnabled = toggle?.checked ?? false;
            speechEnabled = speechPreferenceEnabled;
            initializeSpeechSynthesis();
        });

        // Handle speech toggle
        document.getElementById('toggle-speech').addEventListener('change', function(e) {
            console.log('Speech toggle changed:', e.target.checked);
            speechPreferenceEnabled = e.target.checked;
            speechEnabled = speechPreferenceEnabled;
            if (!speechEnabled) {
                stopCurrentSpeech();
                clearAudioReadingNotice({ unlockQuestion: true });
            } else if (speechPreferenceEnabled && window.room?.readQuestion) {
                // Restart reading with speech if enabled mid-question
                speechHandledThisQuestion = false;
                window.room.readQuestion(Date.now());
            }
        });

        function revealAnswer (message) {
            console.log('revealAnswer called with message:', message);
            const { answer, question, correctAnswer } = message;
            console.log('Destructured values:', { answer, question, correctAnswer });
            
            // Try both old and new element IDs
            const questionElement = document.getElementById('question');
            const answerElement = document.getElementById('answer-display') || document.getElementById('answer');
            const userAnswerElement = document.getElementById('user-answer');
            const pauseButton = document.getElementById('pause');
            const buzzButton = document.getElementById('buzz');
            const nextButton = document.getElementById('next');
            const startButton = document.getElementById('start');
            const toggleCorrectButton = document.getElementById('toggle-correct');
            
            if (questionElement && answerElement) {
                console.log('Setting question and answer elements');
                questionElement.innerHTML = question;
                // Use the correct answer from the tossup if available
                const finalCorrectAnswer = correctAnswer || (window.room?.tossup?.answer);
                console.log('Using correct answer:', finalCorrectAnswer);
                answerElement.innerHTML = 'ANSWER: ' + finalCorrectAnswer;
                if (userAnswerElement) {
                    userAnswerElement.innerHTML = 'YOUR ANSWER: ' + answer;
                }
            } else {
                console.log('Question or answer element not found:', { questionElement, answerElement });
            }
            
            if (pauseButton) pauseButton.disabled = true;
            if (buzzButton) {
                buzzButton.disabled = true;
                buzzButton.textContent = 'Buzz';
            }
            if (nextButton) {
                nextButton.disabled = false;
                nextButton.textContent = 'Next';
            }
            if (startButton) startButton.disabled = false;
            if (toggleCorrectButton) {
                toggleCorrectButton.classList.remove('d-none');
                toggleCorrectButton.textContent = room.previous.isCorrect ? 'I was wrong' : 'I was right';
            }
        }

        // Subject Statistics Functions
        (function initializeSubjectStats () {
            const container = document.getElementById('subject-stats-container');
            const statsBody = document.getElementById('subject-stats-body');
            const refreshButton = document.getElementById('refresh-subject-stats');
            const collapseButton = document.getElementById('toggle-subject-stats');
            const STATS_COLLAPSE_KEY = 'singleplayer-science-bowl-stats-collapsed';
            let statsCollapsed = window.localStorage.getItem(STATS_COLLAPSE_KEY) === 'true';
            let loading = false;

            if (!container || !statsBody) {
                console.error('Subject stats elements not found');
                return;
            }

            function setLoadingState () {
                statsBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">Loading stats...</td></tr>';
                if (refreshButton) {
                    refreshButton.disabled = true;
                    refreshButton.textContent = 'Loading...';
                }
            }

            function setErrorState (message, muted = false) {
                statsBody.innerHTML = `<tr><td colspan="7" class="text-center ${muted ? 'text-muted' : 'text-danger'}">${message}</td></tr>`;
            }

            function finishLoading () {
                if (refreshButton) {
                    refreshButton.disabled = false;
                    refreshButton.textContent = 'Refresh';
                }
            }

            function applyStatsCollapseState () {
                container.classList.toggle('collapsed', statsCollapsed);
                if (collapseButton) {
                    collapseButton.setAttribute('aria-expanded', (!statsCollapsed).toString());
                    collapseButton.title = statsCollapsed ? 'Expand stats' : 'Collapse stats';
                }
            }

            function applySubjectAdjustments (stats, adjustments) {
                if (!adjustments) { return stats; }
                return stats.map(stat => {
                    const subjectKey = (typeof stat.subject === 'string' ? stat.subject.toUpperCase() : stat.subject) || '';
                    const delta = adjustments[subjectKey] || {};
                    const correct = Math.max(0, (stat.correct ?? 0) + (delta.correct ?? 0));
                    const wrong = Math.max(0, (stat.wrong ?? 0) + (delta.wrong ?? 0));
                    const sped = Math.max(0, (stat.sped ?? 0) + (delta.sped ?? 0));
                    const negs = Math.max(0, (stat.negs ?? 0) + (delta.negs ?? 0));
                    return {
                        ...stat,
                        correct,
                        wrong,
                        sped,
                        negs
                    };
                });
            }

            async function fetchSubjectStats () {
                const authResponse = await fetch('/auth/user-stats/science-bowl-subjects');
                if (authResponse.ok) {
                    const data = await authResponse.json();
                    console.log('[SB Stats] Received account stats', data);
                    return { stats: data.stats, source: data.source ?? 'account' };
                }

                if (authResponse.status === 401) {
                    const sessionResponse = await fetch('/api/science-bowl/session-stats');
                    if (sessionResponse.ok) {
                        const data = await sessionResponse.json();
                        console.log('[SB Stats] Using session stats', data);
                        return { stats: data.stats, source: data.source ?? 'session' };
                    }
                    throw new Error('Session stats unavailable');
                }

                throw new Error(`Auth stats request failed (${authResponse.status})`);
            }

            async function loadSubjectStats () {
                if (loading) { return; }
                loading = true;
                setLoadingState();

                try {
                    const { stats, source } = await fetchSubjectStats();
                    const statsSource = source || 'session';
                    let normalizedStats = Array.isArray(stats) ? stats : [];

                    if (statsSource === 'account' && window.sbSubjectStatAdjustments && Object.keys(window.sbSubjectStatAdjustments).length > 0) {
                        normalizedStats = applySubjectAdjustments(normalizedStats, window.sbSubjectStatAdjustments);
                    }

                    if (normalizedStats.length === 0) {
                        setErrorState('No questions recorded yet', true);
                    } else {
                        let totalQuestions = 0;
                        let totalCorrect = 0;
                        let totalWrong = 0;
                        let totalSped = 0;
                        let totalNegs = 0;

                        const rows = normalizedStats.map((stat) => {
                            totalQuestions += stat.total;
                            totalCorrect += stat.correct;
                            totalWrong += stat.wrong;
                            totalSped += stat.sped ?? 0;
                            totalNegs += stat.negs ?? 0;
                            const sped = stat.sped ?? 0;
                            const negs = stat.negs ?? 0;
                            const accuracy = stat.total > 0 ? ((stat.correct / stat.total) * 100).toFixed(1) : '0.0';
                            return `
                                <tr>
                                    <th scope="row">${stat.subject}</th>
                                    <td>${stat.total}</td>
                                    <td>${stat.correct}</td>
                                    <td>${stat.wrong}</td>
                                    <td>${sped}</td>
                                    <td>${negs}</td>
                                    <td>${accuracy}%</td>
                                </tr>
                            `;
                        });

                        const totalAccuracy = totalQuestions > 0 ? ((totalCorrect / totalQuestions) * 100).toFixed(1) : '0.0';
                        rows.push(`
                            <tr class="table-info">
                                <th scope="row"><strong>Total</strong></th>
                                <td><strong>${totalQuestions}</strong></td>
                                <td><strong>${totalCorrect}</strong></td>
                                <td><strong>${totalWrong}</strong></td>
                                <td><strong>${totalSped}</strong></td>
                                <td><strong>${totalNegs}</strong></td>
                                <td><strong>${totalAccuracy}%</strong></td>
                            </tr>
                        `);

                        statsBody.innerHTML = rows.join('');
                    }
                } catch (error) {
                    console.error('[SB Stats] Error fetching subject stats:', error);
                    const message = error?.message ?? 'Unknown error';
                    const isAuthError = /log in/i.test(message);
                    setErrorState(isAuthError ? 'Please log in to view statistics' : `Error: ${message}`, isAuthError);
                } finally {
                    loading = false;
                    finishLoading();
                }
            }

            applyStatsCollapseState();
            collapseButton?.addEventListener('click', () => {
                statsCollapsed = !statsCollapsed;
                try {
                    window.localStorage.setItem(STATS_COLLAPSE_KEY, statsCollapsed ? 'true' : 'false');
                } catch (error) {
                    console.warn('[SB Stats] Failed to persist collapse state', error);
                }
                applyStatsCollapseState();
            });

            refreshButton?.addEventListener('click', loadSubjectStats);
            loadSubjectStats();

            window.refreshScienceBowlSubjectStats = function refreshScienceBowlSubjectStats () {
                loadSubjectStats();
            };
        })();

        // Inline Science Bowl session stat recorder
        (function initializeSessionStatRecorder () {
            const WRONG_TO_CORRECT = 'wrong-to-correct';
            if (!window.sbCorrectedTossupIds) {
                window.sbCorrectedTossupIds = new Set();
            }
            if (typeof window.sbLastRecordedTossupId === 'undefined') {
                window.sbLastRecordedTossupId = null;
            }

            function log (...args) {
                console.log('[SB Session Stats]', ...args);
            }

            function recordSessionStat ({ subject, isCorrect, adjustment, tossupId, isTossup, buzzedEarly, wasNeg, shouldSped } = {}) {
                if (!subject) {
                    log('Skipping stat update - no subject', { isCorrect, adjustment });
                    return;
                }

                if (!adjustment && tossupId) {
                    if (window.sbLastRecordedTossupId === tossupId) {
                        log('Skipping duplicate stat update for tossup', { tossupId });
                        return;
                    }
                    window.sbLastRecordedTossupId = tossupId;
                }

                if (adjustment === WRONG_TO_CORRECT && tossupId) {
                    if (window.sbCorrectedTossupIds.has(tossupId)) {
                        log('Skipping duplicate correction for tossup', { tossupId });
                        return;
                    }
                    window.sbCorrectedTossupIds.add(tossupId);
                }

                const normalizedSubject = subject.toUpperCase();
                log('Recording stat', { subject: normalizedSubject, originalSubject: subject, isCorrect, adjustment, tossupId });

                const payload = adjustment
                    ? { subject: normalizedSubject, adjustment, wasNeg, shouldSped }
                    : { subject: normalizedSubject, isCorrect, isTossup, buzzedEarly };

                fetch('/api/science-bowl/session-stats', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                })
                    .then(async response => {
                        log('Response received', { status: response.status });
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`Failed (${response.status}): ${errorText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        log('Session stats updated', data);
                        window.refreshScienceBowlSubjectStats?.();
                    })
                    .catch(error => {
                        console.error('[SB Session Stats] Error recording stat', { error, subject: normalizedSubject, isCorrect, adjustment, tossupId });
                    });
            }

            window.sbRecordSessionStat = recordSessionStat;
            window.sbSessionStatWrongToCorrect = WRONG_TO_CORRECT;

            function handleMessageForStats (message) {
                if (!message || message.type !== 'give-answer') {
                    return;
                }

                const subject =
                    message?.tossup?.subject ||
                    window.room?.tossup?.subject ||
                    window.room?.previous?.tossup?.subject ||
                    '';
                const isCorrect = message.isCorrect ?? false;
                const tossupId =
                    message?.tossup?._id ||
                    window.room?.tossup?._id ||
                    window.room?.previous?.tossup?._id ||
                    null;

                const isTossup = (message?.tossup?.isTossup ?? window.room?.tossup?.isTossup ?? window.room?.previous?.tossup?.isTossup) === true;
                const celerityFromMessage = typeof message?.perQuestionCelerity === 'number' ? message.perQuestionCelerity : null;
                const celerityFromRoom = typeof window.room?.previous?.celerity === 'number' ? window.room.previous.celerity : null;
                const celerity = celerityFromMessage ?? celerityFromRoom;
                const endOfQuestion = message?.endOfQuestion ?? window.room?.previous?.endOfQuestion ?? null;
                const buzzedEarly = Boolean(isTossup && ((endOfQuestion === false) || (typeof celerity === 'number' && celerity > 0)));

                log('Intercepted give-answer message', {
                    subject,
                    isCorrect,
                    tossupId,
                    messageDirective: message.directive,
                    isTossup,
                    buzzedEarly
                });
                recordSessionStat({ subject, isCorrect, tossupId, isTossup, buzzedEarly });
                if (!isCorrect && window.sbTopicTracker) {
                    const questionText =
                        (window.room?.questionSplit?.join(' ') || '') ||
                        message?.tossup?.question ||
                        document.getElementById('question')?.textContent ||
                        '';
                    const correctAnswer =
                        message?.tossup?.answer ||
                        window.room?.tossup?.answer ||
                        window.room?.previous?.tossup?.answer ||
                        ((document.getElementById('answer-display')?.textContent || '').replace(/^ANSWER:\s*/i, '').trim());
                    const userAnswer =
                        message?.givenAnswer ||
                        message?.answer ||
                        ((document.getElementById('user-answer')?.textContent || '').replace(/^YOUR ANSWER:\s*/i, '').trim());
                    window.sbTopicTracker.trackWrongAnswer({
                        questionText,
                        correctAnswer,
                        category: subject,
                        tossupId,
                        userAnswer
                    });
                }
            }

            function attachEmitterHook () {
                if (!window.room || typeof window.room.emitMessage !== 'function') {
                    console.warn('[SB Session Stats] room not ready, retrying...');
                    setTimeout(attachEmitterHook, 250);
                    return;
                }

                if (window.__sbSessionStatHooked) {
                    return;
                }
                window.__sbSessionStatHooked = true;

                const originalEmitMessage = window.room.emitMessage.bind(window.room);
                window.room.emitMessage = function patchedEmitMessage (message) {
                    try {
                        handleMessageForStats(message);
                    } catch (error) {
                        console.error('[SB Session Stats] Failed to inspect message', error);
                    }
                    return originalEmitMessage(message);
                };

                log('Session stat recorder attached to emitMessage');
            }

            attachEmitterHook();
        })();
    </script>
    
    <!-- Subject Statistics Table - Bottom Right Corner -->
    <div id="subject-stats-container">
        <div id="subject-stats-header" class="w-100">
            <div class="d-flex align-items-center gap-2">
                <h6 class="mb-0 flex-grow-1">Subject Statistics</h6>
                <button class="btn btn-sm btn-outline-secondary" id="toggle-subject-stats" type="button" aria-expanded="true" title="Collapse stats">
                    <i class="bi bi-chevron-down collapse-toggle-icon"></i>
                </button>
                <button class="btn btn-sm btn-outline-secondary" id="refresh-subject-stats" type="button">Refresh</button>
            </div>
        </div>
        <div id="subject-stats-body-wrap">
            <div id="subject-stats-table-container" class="table-responsive">
                <table class="table table-sm table-hover mb-0">
                    <thead>
                        <tr>
                            <th scope="col">Subject</th>
                            <th scope="col">Total</th>
                            <th scope="col">Correct</th>
                            <th scope="col">Wrong</th>
                            <th scope="col">Sped</th>
                            <th scope="col">Negs</th>
                            <th scope="col">Accuracy</th>
                        </tr>
                    </thead>
                    <tbody id="subject-stats-body">
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</body>

</html> 
